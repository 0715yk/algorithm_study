# 퀵정렬
- 피봇을 잡고 그 피봇을 기준으로 왼쪽을 피봇보다 작은쪽 오른쪽을 큰쪽으로 분류해서 합치는 것이 메인 로직임
리스트가 주어지면 먼저, 그 리스트의 인덱스 0 을 피봇으로 잡고(피봇을 잡는 방법은 다양할 수 있음) 새로운 리스트를 변수로 2개 만들어서(a,b)
인덱스 1부터(주어진 리스트)피봇과 비교하면서 피봇보다 작거나 같은 것을 a 리스트에 순서대로 append한다 or 피봇보다 크면 b리스트에 순서대로 append한다
그 결과로 a+[pivot]+b하면 원하는 리스트가 되고, 그것을 리턴한다.
- 퀵정렬은 합병정렬과 같이 시간복잡도가 O(nlogn)으로 상대적으로 빠른 정렬방법이다. 그러나, 합병정렬과 다르게
최악의 경우 O(n**2)의 시간복잡도를 갖는다.. 게다가 그 O(n**2)의 시간복잡도를 가지는 케이스는 다름 아닌 이미 정렬된 리스트이다.
이미 정렬된 리스트를 퀵정렬 방법으로 정렬하려 하면, 피봇을 잡고 앞 뒤로 자기보다 작은 요소, 큰요소를 분류하려해도 이미 정렬되어있기 때문에
앞에는 아무것도 없게되고, 뒤에는 그대로 남아있는 요소들을 넣게된다. 이렇게 남은 요소도 마찬가지로 진행되기 때문에 결국 O(n**2)이 된다.
** 정확한 중간값을 O(n)만에 찾는 알고리즘이 있어서 그것과 함께 쓰면 퀵정렬을 효율적으로 쓸 수 있다고 하는데, 나중에 찾아봐야겠다!

- 위와 같은 퀵정렬도 재귀호출 로직으로 만들 수 있다.
- why? : 진행되는 로직이 같은 로직을 반복하다가 마지막 기저조건을 통해 마무리 되는 형태이므로!

# 재귀 함수 디자인해보기
1) quickSort 함수는 리스트를 받아서 인덱스 0 요소를 pivot으로 잡고, 그 피봇을 기준으로 남은요소를 탐색하며
자신보다 작은 요소들은 leftArr에 큰요소들은 rightArr에 담으며 탐색한다.O(n)
2) 그 다음에 각각의 작은 요소와 큰요에 대해서 또 퀵정렬을 한다. (1번의 반복)
3) 결론적으로 재귀함수는 리스트를 받아서 정렬된 왼쪽 배열 + [피봇 요소] + 정렬된 오른쪽 배열 을 리턴한다.
4) 그리고 이 재귀함수의 기저조건은 만약 전달된 배열의 길이가 1보다 같거나 작으면 그 리스트 자체를 리턴하는 것이다.
5) 이 재귀함수의 n-1이 성립한다고 가정하고 재귀함수(n)을 계산한다.

# 실제 코드 설계해보기

1) 매개변수 l = list를 받기
2) 기저조건
if l.length <= 1 : 
    return l;
else:
    피봇 설정
    pivot = l[0]
    피봇가지고 양 사이드 나누기
    leftArr = []
    rightArr = []
    for i=1 ~ i< l.length :
        if l[i]<=pivot:
            leftArr.push()
        elif l[i]>pivot:
            rightArr.push()
    return quickSort(leftArr) + [pivot] + quickSort(rightArr)
    
# 퀵정렬의 시간복잡도에 관하여
- 사실 이부분은 합병정렬과 굉장히 유사하다. 직접 살펴보면,
먼저, 퀵정렬의 시간복잡도를 T(n)으로 임의로 잡아보면
T(n) = 2*T(n/2) + O(n) 이된다.
여기서 O(n)은 피벗을 기준으로 피벗보다 작은 것을 왼쪽, 큰것을 오른쪽으로 나눌 때 탐색 수행에 걸리는 시간복잡도이다.
합병정렬과 똑같은 형태로 이역시 점화식을 풀어보면
결국 T(n) = O(nlogn)이 됨을 알 수 있다(합병정렬쪽 참고하자)
