합병정렬(merge sort)란?

- O(n lon n)의 시간복잡도를 가지는 정렬 방법으로 선택 및 삽입 그리고 버블 정렬이 O(n**2)의 시간복잡도를 가지는 것과
비교해서 월등한 시간복잡도(효율성)를 가지는 정렬 방법이다.
- 방식에서의 포인트는 리스트를 이등분하여, 그 이등분한 리스트를 각각 왼쪽 리스트, 오른쪽 리스트라고 할 때
왼쪽 리스트만을 가지고 정렬하고, 오른쪽 리스트만을 가지고 정렬해서 정렬한 각각의 리스트를 가지고 맨 앞에서부터 한 요소씩
비교해서 최종 정렬을 하는 것이다.
- 이 때, 왼쪽 리스트가 a, 오른쪽 리스트가 b라고 했을 때, a리스트도 정렬이 되어있고, b리스트도 정렬이 되어있는 상태
(이미 정렬 과정을 거쳤다고 해보자)에서 a([2,4,5,6]),b[1,3,7,8] 이라고 할 때 
앞에서부터 a[0]=2 b[0]=1 를 비교했더니 b[0]가더 작았으므로 새로운 리스트에
[1] 이런식으로 1을 넣어준다.
그 다음으로 a[2,4,5,6] b[3,7,8](1은 정렬했으므로 뺀다) 에서는
a[0] = 2 b[0] =3 이므로
이번에는 [1,2] 즉, 2를 넣어준다.
다시 a[4,5,6] b[3,7,8] 이 남았고 똑같은 방법으로 진행하면
[1,2,3] // a[4,5,6] b[7,8] => .... => [1,2,3,4,5,6,7,8] 로 원하던 오름차순 정렬이된다.

- 다시 돌아와서 합병정렬의 포인트는 아까 말했듯이 1)이등분을 하고, 그 이등분한 리스트를 2)각각 따로 정렬하고, 3) 그 따로 정렬한
리스트를 정렬하면서 합치는 것이 포인트이다.
- 이 때, 위의 포인트를 따라가다보면 합병정렬 과정을 재귀호출 혹은 재귀적으로 구현할 수 있음을 알게되는데, 
위의 과정을 따라가보면,
=> 

1) '리스트를 정렬하기 위해' 먼저, input으로 들어온 리스트를 이등분한다.
2) 이등분한 리스트를 각각 따로 정렬한다.
3) 따로 정렬한 각각의 리스트를 합치면서 하나하나 비교하여 새로운 리스트에 정렬된 리스트가 담기도록 해준다

이 과정에서 2번을 보면 '이등분한 리스트를 각각 따로 정렬'이라고 되어있는데,
결국 이등한 리스트 각각을 따로 정렬하려면 그 정렬 과정에도 합병정렬의 로직을 써야한다.
즉, 다시 1번으로 가서 이등분한 a,b 각각의 리스트를 또 정렬하는 것이다.
그러면 5개의 요소를 가진 리스트가 처음에는 3개짜리 리스트/2개짜리 리스트로 
다음에는 2개짜리 리스트/1개짜리 리스트  // 1개짜리 리스트 / 1개짜리 리스트
마지막으로 1개짜리 리스트/1개짜리 리스트 
이렇게 뿌리를 내리는 것처럼 끊임없이 이등분 됨을 볼 수 있다.
그러다가 마지막에 '기저조건'이 있는데, 결국 리스트의 길이가 0이나 1이되면 그 리스트 자체는 '정렬이 된' 리스트라고 할 수 있다.

위와 같은 로직을 머리속에 가지고 실제로 재귀함수, 재귀호출 로직으로 합병정렬 로직을 구현해볼 수 있다
먼저 설계 단계를 거쳐보면, 

1) 재귀함수를 만들되, 그 재귀함수는 리스트를 받아서 그 리스트를 이등분하고, 각각의 리스트를 정렬한 뒤에 O(n)의 시간복잡도로
각각의 정렬된 리스트를 가지고 대소비교를 하여 최종적으로 정렬된 리스트를 정렬해줘서 리턴하는 함수를 만들 것이다.
2) 이 때, 재귀함수의 '기저조건'은 만약 input으로 받은 리스트의 길이가 0,1이면 그 리스트를 그대로 바로 리턴하는 것이다.

그럼 다음으로, 실제 자바스크립트 코드상으로 구현 설계를 해보자

1) 먼저 함수 이름은 mergeSort로 하고 매개변수로는 l(list)를 받도록 한다.
2) 기저 조건은 if문으로 함수 첫번째줄에 이런식으로 해준다.
if (l.length<=1) return l; 
3) 그럼 기저조건이 아닐 때는
else 문을 써서
먼저, input으로 받은 리스트를 이등분하는데,
예를 들어, l=[4,5,2,1,3,6,7]
이 때, 이등분을 하는 인덱스는 mid = Math.floor(l.length / 2)로 한다.
그래서 left = l.slice(0,mid), right = l.slice(mid) 로 한다.
그리고 이렇게 나눈 리스트를 또다시
sortedLeft=mergeSort(left)
sortedRight=mergeSort(right)
에 재귀호출해준다.
그렇게 리턴된 '정렬이 되었다고 가정한' 배열을 받아서
마지막으로 둘을 대소비교해 최종 정렬된 리스트로 만들어준다.
이 때, 둘중에 짧은 것을 기준으로 비교하면서 작은 것을 빼주고, 새로운 리스트에 넣어줌을 반복하다가
어느 한쪽이 빈배열이 되면 동작을 그만하고, 남아있는 쪽의 배열을 새로운 리스트에 붙여준다(concat)
이는 양쪽다 이미 정렬이된 상태이고,한쪽이 이미다 소진됐다면, 남아있는 쪽은 반드시 그것보다 큰쪽이기 때문에
concat으로 한번에 붙여줘도 된다는 발상이다.
실제로 구현한다면

result = []
while(true) {
    if(sortedLeft[0]>sortedRight[0]) {
        result.push(sortedRight[0])
        sortedRight.shift()
    }else {
        result.push(sortedLeft[0])
        sortedLeft.shift()
    }

    if (sortedLeft.length===0){
        result.concat(sortedRight)
        break
    } else if(sortedRight.length ===0) {
        result.concat(sortedLeft)
        break
    }
}

이런식이 된다. 이 때 O(n)의 시간복잡도가 걸린다.
그리고 이렇게 최종적으로 result를 구했으면
return 해준다.

>>>>>>> 실제 구현 코드는 mergeSort.js <<<<<<<

그렇다면 이러한 합병정렬의 시간복잡도는 어떻게 계산한 것일까?

