#1번 

1 1 : 1
1
2 1+1 : 1 
1을 만들 수 있는 케이스에 1만더해주면됨
1
3 2+1, 1+2, 1+1+1 : 3
2+1
2개 + 1 (2를 만들 수 있는 케이스에 1을 더해줘서 만들면됨)
4 2+2, 2+1+1, 1+2+1, 1+1+2, 1+1+1+1 : 5
1+3+1
3을 만들 수 있는 케이스에 1만더 해주면됨. 
5 2+2+1 2+1+2 1+2+2 2+1+1+1 1+2+1+1 1+1+2+1 1+1+1+2 1+1+1+1+1 : 8 
4를 만들 수 있는 케이스에 +1 
3 + (3+1) + 1

6 2+2+2 2+2+1+1 2+1+2+1 2+1+1+2 1+2+2+1 1+2+1+2 1+1+2+2 2+1+1+1+1 
1 + 6 + 5 + 1 = 13

7 2+2+2+1 *4 2+2+1+1+1 1+2+2+1+1 1+1+2+2+1 1+1+1+2+2 2+1+1+1+1+1
4 + 4 + 3 + 2 + 1 + 6 + 1 = 21 


?피보나치?!
=> 1,1,3,5,8,13,21 
3부터 피보나치임

1 => 1 
2 => 1 
3 => 3 
4 => 5
5 = 4+3 = 8 
n = n-1 + n-2


# 2번

x명의 사람이 있고
y명의 심사관이 있다.
이 때, 심사관마다 심사 시간에 차이가 있음

이 때, 최고로 효율적으로 심사를 해서 가장 빠른 시간 안에 다 심사를 보고자 하는데
그 최소시간이 어떻게 되는지를 묻는 문제임

[x,y,f,r,r,w,f,w,d,c]
이렇게 심사 시간이 주어짐(각각의 인덱스는 심사관 이름이라고 생각)
심사관 0 은 x분 만큼 걸리는 것
n명의 사람 

처음에는 다 비어있음
그러면 일단
1) 기다리는 사람 수 < 심사관 수 => 가장 적게 걸리는 심사관 순서로 투입하고 가장 적게 걸리는 심사관중에 가장 느린 심사관 시간만큼 리턴
2) 기다리는 사람 수 == 심사관 수 => 가장 오래 걸리는 심사관의 시간만큼 걸리고 끝임
3) 기다리는 사람 수 > 심사관 수 => 이게 문제임
: 일단 처음은 무조건 심사관 수만큼의 사람을 심사받게 해야함
일단 시간복잡도 생각안하고 풀어보면 포인트는 비면 넣는 것임 근데또 빈다고 막집어 넣으면 안되는게 최소시간안에 해야하므로...
그래프인가..?
일단 예시 따라해보면
[7,10]
6명

일단 7,10에 2명 바로보냄
그러면 [Full, Full] => 7분동안 / 남은사람 4명
7분후에 [7,Full] => 바로 또 한명 투입 / 남은사람 3명
10분후에 [Full, 10] = 바로 또 한명 투입 / 남은사람 2명
14분후에 [7,Full] = 바로 또 한명 투입 / 남은 사람 1명

여기서 21 분후에 7심사관이 열림 /20분후에 10심사관이 열림
이 때 남은 사람은 1명임 => 
여태까지 한것처럼 20분후에 열리자마자 투입시키면 30분에 끝남
그러나 1분 기다렸다가 7심사관한테 보내면 28분에 끝남..

결국 중요한건 마지막 몇명임.
기다리는 사람 수가 많을 때는 일단 일정수의 사람이 남을 때까지는 계속 돌려야함 심사관 쉬게하면 안됨
결국 1,2,3 조건을 계속측정하면서
기다리는 사람 수가 많으면 계속해서 돌리고,
기다리는 사람 수와 심사관 수가 같아지면 전부다 투입해버리고 끝내고(비어있는 심사관 기준임)
기다리는 사람수보다 비어있는 심사관 수가 많으면 비어있는 심사관 중에 오름차순 정렬해서 차례로 투입시키면 됨 

# 근데 이렇게하면 안된다.. 생각해보니 틀린게 기다리는 사람수와 심사관 수가 같아도 저렇게 처리하면 안됨
예를 들어 심사관 중에 1분단위로 끈는 사람이 있고 10000분이 걸리는 사람이 있으면
아무리 심사관이 다 비어있어도 10000분걸리는 사람한테 애초에 투입하면 안됨...

# 그러면 일단 완전탐색 같은데 .. 완전탐색으로 하면 시간복잡도에서 걸린다..

while문을 써서
한시행마다 1분이 지난다고 설정
minute +=1 
심사위원 배열을 미리 정렬을 해둠 
그 다음에 매 시행마다 지금 제일 작은 수중에 full이 아닌 심사위원을 찾고
full로 해놓음 

# 결과
1) 문제 1 통과
2) 문제 2 - 입국심사 문제 실패.. lv3 결국 통과못함! 
