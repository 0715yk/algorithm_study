#### 문제분석 

단백질을 구하기 위해서 주어진 맵에서 편의점을 도는데,
이 때 특징은 십자가 모양으로만 탐색을 한다는 것이다. 즉, 동서남북이라고 했을 때
동쪽으로 갔다가, 다시 시작점으로 돌아와서 서쪽으로 갔다가, 다시 북쪽, 남쪽 등으로 이런식으로 탐색을 한다는 특징이 있다.
하지만, 걸어온 길을 카운트하고 그런 것은 아니기에 원점으로 돌아왔다가 다시 출발한다는 설정은 상관없을 것 같고,
단지 동서남북으로 탐색을 한다는 것을 기억하면 된다.
(1) 시작점에서 동,서,남,북으로 탐색을 할 수 있는데, 이 때, 반드시 동서남북 각각으로 1칸 이상씩 탐색해야하는 조건이 있긴함.

그리고 이렇게 동서남북으로 탐색을 하면서 마주치는 단백질을 더해서 그 단백질의 총량이 최대값이 되는 포인트에서의 총량을 구하는 문제이다.
이 때, 같은 단백질량은 처리하면 안된다. 즉, 중복은 피하면서 더해야함.
(2) 1에서 말한 시작점에서 동서남북으로 탐색하면서 마주치는 단백질을 더하되, 중복되는것은 제외한다.
그렇게 탐색한 단백질 총량중 가장 많은 단백질 량을 리턴하는 문제

#### 문제 해결책 강구

1) 주어진 정보(N)으로 maps라는 변수로 N*N 배열을 만든다.
- 이 때, 경계선을 만들어야한다. 경계는 -1로 채운다(1겹만)
- 주의할점은 나중에 탐색할 때 maps[2][2]부터  maps[N+1][N+1] 까지 탐색해야한다는 것
(why? 경계처리한 것과 동서남북으로 최소 1이상을 탐색해야하므로)

n = int(input())

limit_line = [[-1 for i in range(n+2)]]
maps = []

for i in range(n):
    maps.append(list(map(int, input().split())))

maps = limit_line + maps + limit_line
answer = 1

for i in range(2,n+2):
    for j in range(2,n+2):
        protein = search_protein((i,j))
        if protein > answer:
            answer = protein

2) 1을 만들었으면 해당 배열을 (2,2)부터 (N+1,N+1) 까지 하나하나 탐색한다.

3) 그리고 그 탐색을 하는 함수를 만든다.
보드와 지금 탐색중인 좌표정보를 받아서
그 좌표를 기준으로 해당 board의 동서남북에 있는 모든 숫자를 더한다.
이 때, 기저조건은 -1을 만나면 한쪽 방향으로의 검색을 멈춘다
그리고, visit이라는 딕셔너리를 만들어놓고
마주친 숫자를 거기에 True로 등록한다. 그러면 다음에 또 그 숫자를 마주치면 카운트하지 않도록 할 수 있다.

=> 동서남북으로 탐색한 다음에 해당 좌표에서 구할 수 있는 단백질의 최대양을 리턴하는 함수

def search_protein(dot)
    global board

    ways = [(-1,0), (0,1), (1,0), (0,-1)]
    visit ={}
    result = board[dot[0]][dot[1]]
    visit[result] = True

    for way in ways:
        x = dot[0] + way[0]
        y = dot[1] + way[1]

        while board[x][y] != -1:
            try:
                if visit[board[x][y]]:
                    continue
            except:
                visit[board[x][y]] = True
                result += board[x][y]
            x += way[0]
            y += way[1]        

    return result


4) 그러면 3번의 함수를 이용해서 2번의 탐색의 매시행마다 탐색 중인 좌표를 넣어준다.
그러면서 전역변수에 놨던 answer 변수( -1 디폴트로 된)를 이용해서 최대값을 계속해서 갱신해준다.
그리고 끝까지 갔을 때 answer에 들어있는 값을 최종 print하면 된다.
