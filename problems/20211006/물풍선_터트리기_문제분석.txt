#### 문제해석 

정보를 통해 주어진 물풍선을 
주어진 바늘의 개수인 K개의 바늘을 사용해서
최대한 많이(연쇄 작용을 일으켜서) 터트린 다음에 
- (1) 1차 목표는 k개의 바늘로 최대한 많은 바늘을 터트리는 것(연쇄 작용을 일으켜야함)

그래도 물풍선이 남았을 때
그 때도 최소한의 바늘을 써서(즉, 최대로 많은 연쇄작용을 일으켜서) 남은 물풍선을 터트려야하는데
이 때 남은 물풍선을 터트릴 때 필요한 최소한의 바늘 개수를 구하는 것이 이문제의 목표이다. 
- (2) 최종 목표는 남은 물풍선을 터트릴 수 있는 최소한의 바늘 개수를 구하는 것 


#### 문제 설계 

일단 1번을 해결하기 위해서는 
최대한의 연쇄작용을 일으킬 수 있는 물풍선을 찾아야함.
혹은 결과적으로 터트렸을 때 한번에 최대한 많이 터트릴 수 있는 조합을 찾아내야함 
근데 그게 바늘 한개만 써서 가능할수도 있고, k개 다써야할 수도 있고, k개를 다써도 불가능할수도 있음

그러면 결국 완전탐색식을 생각해보자. 즉, '터트리는 모든 경우의 수를 생각해보자' 일단은
예시
10 9 2
0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 
0 10 4 0 0 1 0 5 3 
0 0 0 0 0 0 0 0 0 
2 0 0 0 0 0 4 0 0 
0 0 3 5 0 1 0 0 0 
10 0 0 0 0 3 0 0 0 
0 0 0 0 4 0 0 0 0 
0 0 1 0 0 10 0 4 0 
0 0 0 0 0 0 3 0 0 

이 예시로 해보자

k = 2, 즉, 2개의 바늘이 주어진다.
& 근데 생각해보면 유효범위 내에 가장 많은 물풍선을 가진 물풍선을 터트리는게 가장 효율적이지 않을까? 
그러면 저 예시에서 하나하나 탐색해보면
(3,2)의 10 : (4,1,5,3) 4개 
(3,3)의 4 : (10,1,3) 3개 
(3,6)의 1 : 0개 
(3,8)의 5 : (4,3) 2개 
=> 위에줄에서는 10이 가장 많이 터트림 근데 또 생각해보면 저렇게 유효범위 내에 물풍선이 많다고 해도
만약에 2개밖에 없는 5를 터트렸을 때 터지는 3이 근처에 10을 두고 있어서 10을터트렸는데, 그 10의 유효범위 내에 물풍선이 엄청 많고
정작 여기서는 최대였던 10을 터트렸더니 유효범위 내의 것들이 다 1이어서 자기들끼리만 터지고 만다면 사실상 전자가 더 효율적인 물풍선이된다. 
이건 진짜 다 해보는 수밖에 없을 것 같다..

그러면 위의 방법이 아닌
10, 4, 1, 5 ,3 2,3,5,1,10,3,1,10,3,4 
이렇게 모든 물풍선을 가지고 하나하나 해보자
이 때, 최대 15개의 물풍선을 둔다했고, n*m은 최대 100개의 dot을 가진다

15 14 13 12 11 10 9 8 ..... 1 15!개 의 조합이 있을 수 있다. ..그러나,
만약에 이 최악의 케이스를 다해보면 '1307674368000' 개의 조합을 탐색하게된다.
하지만 k의 범위가 0부터 4이므로 저정도는 안된다.
15*14*13*12 이게 최악의 케이스 조합일 것이다(32760).
이정도는 할만하다.
최악의 경우 저정도 조합을 순서대로 터트려보는거다 예를 들어
위의 예시로 치면
(10,4,1,5) 순서로 먼저 터트리고, (10,1,5,4) 이렇게도 터트려보고 이런식으로 
그러다보면 

# 근데 여기서 또 문제가 있다..
만약에 15개 전체를 사악하게(?) 범위를 1만 터지는 물풍선으로 흩어지게 해놓으면 
저렇게 K의 범위가 작더라도 결국 나머지를 터트리는 경우의 수를 따져봐야하기때문에 
'만약에 이 최악의 케이스를 다해보면 '1307674368000' 개의 조합을 탐색하게된다.'
이 최악의 조건에 해당하는 탐색을 하게 된다..

# 더 효율적인 방법이 필요하다. 
- (1) 1차 목표는 k개의 바늘로 최대한 많은 바늘을 터트리는 것(연쇄 작용을 일으켜야함)
- (2) 최종 목표는 남은 물풍선을 터트릴 수 있는 최소한의 바늘 개수를 구하는 것 

이 두개를 한번에 하던지.. 저런 완전탐색적(?) 방법이 아닌 다른 것을 찾아봐야함
흠 근데 또 간단하게 생각해보니까 
==================================================================================================
처음에 했던 '& 근데 생각해보면 유효범위 내에 가장 많은 물풍선을 가진 물풍선을 터트리는게 가장 효율적이지 않을까? '
이생각에서 나아가서
먼저, '주어진 최대 15개의 물풍선을 하나씩 터트려보는거다 BFS로'
예를 들어, 위에서 맨처음 10을 터트려보면 그에 따라 터지는 모든 물풍선을 다 터트리는거다 (BFS로 구현가능)
그렇게 첫번쨰 시행에서 15개를 다 터트려본다 불가능한 케이스지만 대략 정말 최악이라도 1500번밖에 안한다(시행)
그렇게 다 터트려본 결과 다터트렸으면 그냥 0을 리턴하면되고
다 안터졌으면 '가장 많이 터트린 케이스를 선택한다'(탐색하면서 최대 터트린 물풍선의 값과, 좌표, 그리고 그때의 터트린 정보 board를 갱신저장하면서 한다)
예를 들어 위에서는 10이라고 하면 (3,2) 10을 터트린 케이스로 board를 갱신한다

그렇게 첫번쨰 시행이 끝났고(k-=1)
두번째 시행을 위와 똑같은 과정으로 진행한다
이 때 시행을 하면서 k가 0이되면 그 때부터는 answer += 1 을 시작한다 .
그렇게 계속 시행을 하다가 
물풍선의 개수가 0이 됐을 때 k가 여전히 양수이면 0을 리턴하면되고
k가 0이면 answer을 리턴하면 된다.
==================================================================================================
이 아이디어로 구현설계해본다. 

#### 구현 설계

1) 주어진 최대 15개의 풍선을 하나씩 터트려보려면 이 정보를 받아놔야한다. 처음에 board를 만들 때 튜플로 좌표값을 받아놓자(배열에)
그리고, 그 좌표값을 가지고 이 물풍선의 파괴력(범위)을 알기 쉽게 power={}라는 딕셔너리에 좌표를 키로 유효범위를 값으로 두자 (좌표는 유일하므로)
그러면 power, queue(물풍선 좌표정보를 담은 배열) 이 두개가 board를 만들고 생성됐을 것이다.

2) 각 시행마다 BFS로 물풍선을 터트려볼건데 이 때, board를 copy해서 해야한다. 하나의 물풍선을 택해서 터트려서 퍼지는걸보려면
각각의 물풍선을 터트리는 BFS 시행마다(queue에 있는 물풍선 각각을 말함) 같은 board 상태에서 해야하기에 영향을 주면 안된다.
그러면 이걸 함수로 만들자
함수명 : BFS
global : board 
매개변수 : 터트릴 물풍선 좌표값 root
board를  global 변수로 줘서 함수를 실행할 때마다 BFS를 돌릴 것이기에 이 안에서 board를 copy한다.
* board copy코드

copy_board = copy.deepcopy(board) # 일단 라이브러리를 쓴다 후에 시간복잡도 문제되면 수정 하기(100*100이 최대라 괜찮을 것 같지만)
queue = [root]

while len(queue) != 0:
    top = queue.pop(0)
    # 물풍선을 하나씩 뺄 것이고, 그것이 터지면 영향을 미칠 물풍선을 큐에 담아가면서 다 터트리는 방식 
    # 이 때, 하나씩 빼서 터트리는 물풍선은 copy_board에 0으로 처리하고
    [next_queue, next_copy_board] = search_area(top, copy_board)
    queue += next_queue
    copy_board = next_copy_board
  ** 이 때, top에 해당하는 물풍선이 터트릴 물풍선의 범위를 탐색하면서 해당 물풍선을 큐에 추가하는 함수 
   def search_area(dot, board):
     # 함수 내에 큐를 생성
     # board는 copy_board를 매개변수로 넣어준다
     global power 

     queue = []
     board[dot[0]][dot[1]] = 0
    
     d = [(-1,0),(0,1),(1,0),(0,-1)]
    
     for el in d:
       x = dot[0] + el[0]
       y = dot[1] + el[1]

       for i in range(power[dot]):
           if board[x][y] == -1:
             break
           elif board[x][y] != 0:
             queue.append((x,y))
           x += el[0]
           y += el[1]
            
     return [queue, board]


