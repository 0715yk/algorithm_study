비행기에서 9로 착륙한다 (시간카운트x)
착륙한다음에 맵 전체를 훑으면서 사살할 적을 탐색해야한다
탐색한 다음에 위쪽을 먼저 가도록하는데 만약 위쪽에도 적이 많으면 위쪽에서 왼쪽을 먼저간다

포인트는 
자기보다 낮은 레벨의 적만 죽일 수 있다는 것이다.
그래서 자기 레벨을 초과하는 적쪽으로는 탐색을 하지 않을 것이다.
이 때, 자기와 레벨이 같은 적은 통과할 수 있기 때문에 자기보다 레벨이 작은 적을 찾기위해 통과할 수는 있다.

1) 사살할 수 있는 적이 있는지 탐색한다
=> 처음에 map을 배열로 만들 때 0과 9를 제외한 모든 수의 좌표를 찍으면서 카운트할 수 있다.
이 때, 처음에 사살할 수 있는 적만 파악하면 되므로 2레벨에서 잡을 수 있는 1레벨의 좌표만 카운트한다
예시를 바탕으로 해보면
0 1 0 1 0 
0 0 0 0 2 
0 2 0 2 0 
0 3 9 0 0 
1 3 0 0 0 

9에서 착륙한다음에
9에서 BFS를 해서 자기보다 낮은 레벨을 찾는다
찾으면 거기로 간다 
BFS 순서는 위 왼쪽 아래 오른쪽 
이 때 BFS 탐색하다가 자기보다 레벨이 낮은 적이 나오면 거기 1 죽이고, 거기서 멈춘다
자기랑 레벨이 같은 적이 나오면 그냥 통과한다
자기보다 레벨이 높은적이 나온 부분으로는 탐색 멈춤

=> 적을 죽이고 멈췄으면
다시 거기서 같은 방식으로 BFS를 해서 1을 찾을 떄까지 간다
그리고 똑같은 로직
이런식으로 계속 간다.

중간에 레벨이 바뀔 것이고 그러면 통과하는 곳, 적을 잡는 시점, 레벨이 높은 적을 걸러내는 로직도 자연스레 변할 것

# 다시 구현 설계하면서 자세히 얘기해보면
0) lv = 2 로 시작한다
1) 먼저 배열을 받으면서 9의 좌표를 얻고 queue에 넣는다
2) 그럼 그 queue 를 기준으로 BFS를 한다. 
3) BFS는 위 왼쪽 오른쪽 아래의 순서로 한다 => 위쪽 먼저보고 왼쪽보는 방식이므로
4) 만약에 자기보다 레벨이 낮은 적을 찾으면 0으로 바꾸고, 거기서 BFS를 멈춘다 (여기에 적 섬멸 count ++ )
5) 자기랑 레벨이 같은 적을 만날경우 0과 같은 취급으로 지나간다
6) 자기보다 레벨이 높은 적을 만날 경우 경계 부분과 같은 처리로 더이상 탐색하지 않는다.
7) 이렇게 또 멈춰선 좌표부터 새로 queue(초기화됨)에 넣고 똑같이 BFS를 한다 
8) 그러다보면 또 1번처럼 적을 죽이게 된다 그러면 또 적 섬멸 count ++ 한다
9) 이 때 적 섬멸 count가 레벨과 같아지면? lv ++ 한다.
10) 그렇게 계속 BFS를 돌린다 레벨변수가 올라가면서 자연스럽게 로직이 완성된다
11) 계속 돌리다가 적 count가 0이 되는 순간 끝난다.
12) 혹은 BFS를 전부다 돌았는데, 자기보다 낮은 레벨을 못만나면 끝난다.

# 코딩 구현 설계

1) n을 입력받고
주어진 맵을 배열로 만든다.
- 경계처리는 굳이 따로하지 않기위해 100을 경계로 둔다(레벨 제한상 절대 이길 수 없는 적이기에 + 자기보다 높은 적은 패스한다는 조건)
- 배열을 만들면서 적의 개수를 센다(적이 다 죽으면 break하려고)
- 배열을 만들면서 9의 좌표를 찾아서 변수에 저장한다(root)

2) root 좌표를 얻었으면 queue에 넣고 BFS를 시작하는 로직을 만든다
이 때, 계속해서 BFS를 할 것이기에 while안에 또 while문을 넣게 될 것
이 때 BFS 하는 로직은 함수로 따로 관리해야 코드가 간소화될 것 

def BFS 만들어서

queue를 매개변수로 받고, 
queue를 바탕으로 BFS시작 => 
북서동남 순서로 탐색 
만약에 이미 방문한 기록이 있으면 pass해야하므로 방문할 때마다 path[좌표] = True를 해놓음
탐색하면서 min라는 딕셔너리에 각각의 걸린시간(거리)를 적어둠 

- 만약에 탐색을 하다가 현재 lv 보다 높은 수를 만나면 continue임 다음 queue에 넣을 필요 x
- 자기와 같은 레벨을 만나면 queue에만 넣고 pass 
- 자기보다 낮은 레벨을 만나면 여기까지 걸린 시간을 return BFS를 종료함(함수를 종료) 
- 근데 만약 끝까지 탐색했는데 자기보다 낮은 레벨을 못만났다 하면, len(queue) == 0 이면 -1 을 리턴함
- 그러면 만약 BFS의 결과가 -1이면 더이상 섬멸할 적이 없으므로 그때까지 더한 total_min이 답이고
- BFS의 결과가 -1이 아니면 total_min+= 해주면 됨

이렇게 한번의 함수가 끝나면 
다시 while문으로 돌아가서 다시 함수를 돌리는데 이 때는 queue가 달라져야하고, 원본 맵 배열에는 이전의 섬멸한 적이 없어져있어야함
- 그래서 생각해보니까 함수에서 리턴할 때 global로 queue를 해놓고, queue를 리셋하고 섬멸한 적의 좌표를 새로 넣어서 return 해야할듯
- (섬멸한 적이 없으면 어차피 -1리턴할테니까 상관x)

이렇게 계속 함수를 돌리면 total_min이 쌓일테고, 함수 안에서 적을 다죽였는지, 못죽였는지는 안나오겠지만 
어쨌든 둘중 하나가 일어날때까지(다죽이는 상황, 더이상 못죽이는 상황) 돌리다가 total_min을 알아서 리턴할 것임

이 때, N은 최대 20이라 시간복잡도는 고려하지 않아도 된다. 충분함

# 그럼 실제 구현해보자

#1차 구현 에러# 

# 9를 0으로 놓는 것 깜빡...9는 착륙지점이기 때문에 착륙 후에는 0으로 지나갈 수 있게끔 만들어줘야함
# 본인보다 낮은 레벨을 찾더라도 거기서 끝내면 안되고
# 그 거리 내에 해당 하는 또다른 레벨이 낮은 적이 없는지 확인해야함
# 그런 다음에 같은 거리에 내에 두명의 적 이상이 있다면
# 둘 사이에서 x값이 적은쪽을 택해야하고,
# x가 동일하면 y가 적은쪽을 택해야함 

그러면 내가 설계한 while문(BFS) 형태를 바꿔야함
while로 queue에 추가하면서 탐색하면 안되고

queue에 대한 for문으로
현재 거리를 명확히 알 수 있도록 해야함 
하나 팝하면 거기서 갈 수 있는 방향 전부를 next_queue에 넣기
그러면 next_queue로 탐색을 하다가 만약에 낮은 레벨 적이 없으면
탐색을 하면서 next_queue를 새로 갱신해야함 

# 총평

- 문제를 잘못읽음.. 위쪽 아니면 왼쪽인 것을 판별할 때 x축이 작은 쪽이 우선순위 높은거고,
x값이 같으면 y축이 작은게 우선순위인데 잘못 생각함.
- 위의 포인트 빼고는(9를 0으로 놓는 것 깜빡하는 것도..) 설계한대로 됐다.